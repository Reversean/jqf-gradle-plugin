/* START OF JQF Authors' Copyright
 *
 * Copyright (c) 2017-2018 The Regents of the University of California
 * Copyright (c) 2020-2021 Rohan Padhye
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * END OF JQF Authors' Copyright
 *
 * Authors of this file used source code from https://github.com/rohanpadhye/JQF following the
 *  copyright notice provided above.
 */
package com.mborzenkov.jqfgradleplugin.task;

import com.mborzenkov.jqfgradleplugin.JqfUtil;
import edu.berkeley.cs.jqf.fuzz.junit.GuidedFuzzing;
import edu.berkeley.cs.jqf.fuzz.repro.ReproGuidance;
import edu.berkeley.cs.jqf.instrument.InstrumentingClassLoader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.net.MalformedURLException;
import java.util.List;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import org.gradle.api.DefaultTask;
import org.gradle.api.GradleException;
import org.gradle.api.Project;
import org.gradle.api.logging.Logger;
import org.gradle.api.tasks.TaskAction;
import org.gradle.api.tasks.options.Option;
import org.junit.runner.Result;

/**
 * Repro task for JQF.
 */
public class JqfReproTask extends DefaultTask {

  public static final String USAGE = "./gradlew repro --class=com.example.YourTestClass "
      + "--method=yourTestMethod --input=build/fuzz-results/yourTestClassPath/yourTestMethod"
      + "/failures/id_000000";

  private String testClassName;
  private String testMethod;
  private String input;
  private String logCoverage;
  private String excludes;
  private String includes;
  private boolean printArgs;
  private String dumpArgsDir;

  @Option(
      option = "class",
      description = "The fully-qualified name of the test class containing methods to fuzz.\n\n"
          + "See jqf fuzz."
  )
  void setTestClassName(String testClassName) {
    this.testClassName = testClassName;
  }

  @Option(
      option = "method",
      description = "The name of the method to fuzz.\n"
          + "See jqf fuzz."
  )
  void setTestMethod(String testMethod) {
    this.testMethod = testMethod;
  }

  @Option(
      option = "input",
      description = "Input file or directory to reproduce test case(s).\n\n"
          + "These files will typically be taken from the test corpus (\"queue\") directory or the "
          + "failures (\"crashes\") directory\n generated by JQF in a previous fuzzing run, for "
          + "the same test class and method."
  )
  public void setInput(String input) {
    this.input = input;
  }

  @Option(
      option = "logCoverage",
      description = "Output file to dump coverage info.\n\n"
          + "This is an optional parameter. If set, the value is the name of a file where JQF will "
          + "dump code coverage information for the test inputs being replayed."
  )
  public void setLogCoverage(String logCoverage) {
    this.logCoverage = logCoverage;
  }

  @Option(
      option = "excludes",
      description = "Comma-separated list of FQN prefixes to exclude from coverage.\n\n"
          + "See jqf fuzz."
  )
  void setExcludes(String excludes) {
    this.excludes = excludes;
  }

  @Option(
      option = "includes",
      description = "Comma-separated list of FQN prefixes to forcibly include, even if they"
          + "See jqf fuzz."
  )
  void setIncludes(String includes) {
    this.includes = includes;
  }

  @Option(
      option = "printArgs",
      description = "Whether to print the args to each test case.\n\n"
          + "The input file being repro'd is usually a sequence of bytes that is decoded by the "
          + "junit-quickcheck generators corresponding to the parameters declared in the test "
          + "method. Unless the test method contains just one arg of type InputStream, the input "
          + "file itself does not directly correspond to the args sent to the test method.\n\n"
          + "If this flag is set, then the args decoded from a repro'd input file are first "
          + "printed to standard output before invoking the test method."
  )
  public void setPrintArgs(boolean printArgs) {
    this.printArgs = printArgs;
  }

  @Option(
      option = "dumpArgsDir",
      description = "Whether to dump the args to each test case to file(s).\n\n"
          + "The input file being repro'd is usually a sequence of bytes that is decoded by the "
          + "junit-quickcheck generators corresponding to the parameters declared in the test "
          + "method. Unless the test method contains just one arg of type InputStream, the input "
          + "file itself does not directly correspond to the args sent to the test method.\n\n"
          + "If provided, then the args decoded from a repro'd input file are dumped to "
          + "corresponding files in this directory before invoking the test method."
  )
  public void setDumpArgsDir(String dumpArgsDir) {
    this.dumpArgsDir = dumpArgsDir;
  }

  @TaskAction
  void repro() {
    validateOptions();

    final Project project = getProject();
    final Logger logger = project.getLogger();

    ClassLoader loader;
    ReproGuidance guidance;
    Result result;

    final PrintStream out = logger.isDebugEnabled() ? System.out : null;

    // Configure classes to instrument
    if (excludes != null) {
      System.setProperty("janala.excludes", excludes);
    }
    if (includes != null) {
      System.setProperty("janala.includes", includes);
    }

    try {
      List<String> classpathElements = JqfUtil.getTestClasspathElements(project);
      loader = new InstrumentingClassLoader(
          classpathElements.toArray(new String[0]),
          getClass().getClassLoader());
    } catch (GradleException | MalformedURLException e) {
      throw new GradleException("Could not get project classpath", e);
    }

    // If a coverage dump file was provided, enable logging via system property
    if (logCoverage != null) {
      System.setProperty("jqf.repro.logUniqueBranches", "true");
    }

    // If args should be printed, set system property
    if (printArgs) {
      System.setProperty("jqf.repro.printArgs", "true");
    }

    // If args should be dumped, set system property
    if (dumpArgsDir != null) {
      System.setProperty("jqf.repro.dumpArgsDir", dumpArgsDir);
    }

    File inputFile = new File(input);
    if (!inputFile.exists() || !inputFile.canRead()) {
      throw new GradleException("Option --input is non-existent or non-readable file");
    }

    try {
      guidance = new ReproGuidance(inputFile, null);
      result = GuidedFuzzing.run(testClassName, testMethod, loader, guidance, out);
    } catch (ClassNotFoundException e) {
      throw new GradleException("Could not load test class", e);
    } catch (IllegalArgumentException e) {
      throw new GradleException("Bad request", e);
    } catch (FileNotFoundException e) {
      throw new GradleException("File not found", e);
    } catch (IOException e) {
      throw new GradleException("I/O error", e);
    } catch (RuntimeException e) {
      throw new GradleException("Internal error", e);
    }

    // If a coverage dump file was provided, then dump coverage
    if (logCoverage != null) {
      Set<String> coverageSet = guidance.getBranchesCovered();
      assert (coverageSet != null); // Should not happen if we set the system property above
      SortedSet<String> sortedCoverage = new TreeSet<>(coverageSet);
      try (PrintWriter covOut = new PrintWriter(new File(logCoverage))) {
        for (String b : sortedCoverage) {
          covOut.println(b);
        }
      } catch (IOException e) {
        logger.error("Could not dump coverage info.", e);
      }
    }

    if (!result.wasSuccessful()) {
      throw new GradleException("Test case produces a failure.");
    }
  }

  private void validateOptions() {
    if (testClassName == null || testClassName.isEmpty()) {
      throw new GradleException("Option --class is required.\n" + USAGE);
    }
    if (testMethod == null || testMethod.isEmpty()) {
      throw new GradleException("Option --method is required.\n" + USAGE);
    }
    if (input == null || input.isEmpty()) {
      throw new GradleException("Option --input is required.\n" + USAGE);
    }
  }
}
